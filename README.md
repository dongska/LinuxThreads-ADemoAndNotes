# LinuxThreads-ADemoAndNotes
该仓库包括关于Linux线程的知识点笔记，并且通过一个“多线程拷贝”的小Demo作为应用。

小DEmO的源文件及readme在子文件夹中。
***
# Linux线程的知识点笔记

# 进程开发系统API接口

## fork函数

该函数用于创建进程。<br>创建进程的继承与被创建的进程有亲缘关系。Linux系统中，除了init进程外都有父进程。

fork函数的执行过程：可以看作有三部分1、自进程的创建2、子进程的初始化+return3、return

fork函数的返回值：对父进程：在克隆阶段返回子进程PID。对子进程：在子进程中，fork 函数结束时返回0。创建失败返回-1.

子进程的执行范围:子进程中，从fork执行到末尾。

三个版本的fork函数：

1.父进程用户区完全拷贝给子进程，

2.vFork 子进程没有用户空间，结合exec函数使用

3.读共享，写复制机制
![image](https://user-images.githubusercontent.com/104555286/205937138-b708477b-2df2-4a47-af6b-2a07f69ac8c7.png)


通过fork函数的返回值区分父子函数，

## exec函数

进程功能（用户区）重载。可以加载某个程序的用户层（功能），加入到一个进程中、

> 二次包裹：在系统函数的基础上，封装新的函数。

返回值：源程序的返回值代码已经被覆盖，返回值为重载函数的返回值
![image](https://user-images.githubusercontent.com/104555286/205937002-95e72ffc-fcd5-48a1-94da-681d37b2d569.png)


execl

参数：execl(“源程序的位置” ，“参数1",...,NULL);

函数执行：

execlp

p代表系统可以自行查找命令位置。不需要手动写

execv

使用数组进行传参。

execvp

不需要手动写命令的绝对位置，参数使用数组。

execve（系统函数）

e表示修改进程的环境的变量，使用新的进行覆盖

### exec的应用

#### web CGI接口

网站中的功能利用进程重载对应的用户区即可、不需要改变网站代码。
![image](https://user-images.githubusercontent.com/104555286/205936777-221db2f6-908b-4fa1-bb01-93d89ef34422.png)



***

## 僵尸进程 Z+

产生原因：子进程先于父进程结束，子进程用户层被回收，部分内核层回收，pcb被残留变成僵尸进程。<br>父进程可以回收僵尸进程，同时，可以通过残留的pcb进行验尸，提取子进程结束的原因。

危害：

1. 内存泄漏，PCB未被回收，占用内存空间。pcb结构体有384个成员，某些成员还会额外申请内存，pcb指向的内存无法被使用。
1. 系统中进程的创建取决于PCB数量，如果大量僵尸进程占用PCB，会影响进程创建，僵尸越多，可创建的进程越少。进程的数量是固定的。

回收：

Linux系统中，子进程的pcb回收只能由父进程回收。父进程了也可以使用pcb查看子进程死亡的原因。子进程是自行退出还是被杀死，父进程进行推出校验。

### 僵尸进程的回收

通过wait函数回收僵尸进程。具体如下：

wait（int* status);

阻塞回收函数，执行后进入等待，子进程结束后，唤醒该函数回收残留，然后返回，

int* status：用于接收回收pcb时子进程的退出原因，后序父进程可以通过status进行退出校验，如果不关心，传NULL

返回值：回收成功返回子进程PId,如果失败、没有子进程返回-1

wait_pid (pid_t pid, int * status, int opt);

pid_t pid :   >0可以指定回收，-1 回收任意一个子进程，0 回收与父进程同组的一个子进程，<-1 指定回收某一个进程组的一个子进程

opt: WNOHANG 非阻塞回收的参数

返回值：>0回收成功 子进程ID, =0没有可回收的子进程，-1回收失败

### 退出校验
具体函数如下图：
![image](https://user-images.githubusercontent.com/104555286/205936046-e84d14d5-ed31-4663-b78e-209e8b4dd26c.png)

